// Generated by CoffeeScript 1.3.3
(function() {
  var accessApi, apiKey, config, fs, getConfiguration, handleWordQuery, handleWordUpdate, mongo, processRequest, request, thesaurus, url;

  url = require("url");

  request = require("request");

  fs = require("fs");

  mongo = require("mongojs");

  config = getConfiguration(fs("api/config.json"));

  apiKey = config.thesaurus_api_key;

  thesaurus = mongo.connect(config.db_url, ["words"]);

  getConfiguration = function(fs, path) {
    var cfg;
    try {
      cfg = JSON.parse(fs.readFileSync(path).toString());
      if (process.env.NODE_ENV !== "production") {
        cfg.db_url = "thesaurus";
      }
      return cfg;
    } catch (e) {
      console.error("There was an error getting configuration data:");
      console.log(e);
      return process.exit(1);
    }
  };

  handleWordQuery = function(request, response) {
    var word;
    word = processRequest(request);
    if (word) {
      return thesaurus.words.find({
        is: word
      }, function(error, result) {
        if (error) {
          console.error("There was an query error:");
          return console.log(error);
        } else if (result && result[0] && result[0].is === word) {
          try {
            response.writeHead(200, {
              "Content-type": "text/json"
            });
            return response.end(JSON.stringify(result[0]));
          } catch (e) {
            console.error("There was a parse error:");
            return console.log(e);
          }
        } else {
          return accessApi(word, response);
        }
      });
    } else {
      response.writeHead(400);
      return response.end();
    }
  };

  accessApi = function(word, response) {
    var processWordData;
    processWordData = function(word, wordStr) {
      var i, listType, objects, strings, types, wordType;
      word.is = wordStr;
      word.rank = 0;
      types = [];
      strings = void 0;
      objects = void 0;
      for (wordType in word) {
        if (wordType !== "is" && wordType !== "rank") {
          for (listType in word[wordType]) {
            strings = word[wordType][listType];
            objects = [];
            if (strings && strings.length) {
              i = 0;
              while (i < strings.length) {
                objects.push({
                  is: strings[i]
                });
                i++;
              }
              word[wordType][listType] = objects;
            }
          }
          types.push(wordType);
        }
      }
      word.types = types;
      return word;
    };
    if (apiKey) {
      url = "http://words.bighugelabs.com/api/2/" + apiKey + "/" + word + "/json";
      return request(url, function(error, headers, body) {
        var wordObject;
        if (!error && headers.statusCode === 200) {
          try {
            wordObject = processWordData(JSON.parse(body), word);
            response.writeHead(200, {
              "Content-type": "text/json"
            });
            response.end(JSON.stringify(wordObject));
            return thesaurus.words.save(wordObject, function(error, saved) {
              if (error || !saved) {
                console.error("There was a problem saving a word:");
                console.log(error);
                return console.log(wordObject);
              }
            });
          } catch (e) {
            console.error("There was a parse error:");
            return console.log(e);
          }
        } else {
          console.error("API access error:");
          console.log(error);
          return console.log(headers);
        }
      });
    }
  };

  handleWordUpdate = function(request, response) {
    var source, synonym, synonymQuery, synonymRankInc, type, words;
    words = processRequest(request);
    if (words) {
      source = words.original;
      synonym = words.replacement;
      type = words.type;
      synonymQuery = {
        is: source
      };
      synonymQuery[type + ".is"] = synonym;
      synonymRankInc = {
        $inc: {}
      };
      synonymRankInc.$inc[type + ".$.rank"] = 1;
      console.log(synonymQuery);
      console.log(synonymRankInc);
      return thesaurus.words.update(synonymQuery, synonymRankInc, function(error, updated) {
        thesaurus.words.find({
          is: source
        }, function(e, result) {
          return console.log(result);
        });
        if (error) {
          console.error("Word not updated.");
          return console.log(error);
        } else {
          return updated;
        }
      });
    }
  };

  processRequest = function(request) {
    var data, type, validateGet, validatePost;
    validateGet = function(data) {
      if ("word" in data.query) {
        return data.query.word;
      } else {
        return null;
      }
    };
    validatePost = function(data) {
      if ("original" in data.query && "replacement" in data.query && "type" in data.query) {
        return data.query;
      } else {
        return null;
      }
    };
    data = url.parse(request.url, true);
    type = request.method;
    if ("query" in data && data.query && (type === "GET" || type === "POST")) {
      return (type === "GET" ? validateGet(data) : validatePost(data));
    }
  };

  module.exports.handleWordQuery = handleWordQuery;

  module.exports.handleWordUpdate = handleWordUpdate;

}).call(this);
