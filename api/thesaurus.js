// Generated by CoffeeScript 1.3.3
(function() {
  var accessApi, apiKey, config, fs, getConfiguration, handleWordQuery, handleWordUpdate, mongo, output, processRequest, request, thesaurus, url,
    __slice = [].slice;

  url = require('url');

  request = require('request');

  fs = require('fs');

  mongo = require('mongojs');

  output = function() {
    var item, log, msg, _i, _len, _results;
    msg = arguments[0], log = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    console.error(msg);
    _results = [];
    for (_i = 0, _len = log.length; _i < _len; _i++) {
      item = log[_i];
      _results.push(console.log(item));
    }
    return _results;
  };

  getConfiguration = function(fs, path) {
    var cfg;
    try {
      cfg = JSON.parse(fs.readFileSync(path).toString());
      if (process.env.NODE_ENV !== 'production') {
        //cfg.db_url = 'thesaurus';
      }
      return cfg;
    } catch (e) {
      output('There was an error getting configuration data:', e);
      return process.exit(1);
    }
  };

  config = getConfiguration(fs, 'api/config.json');

  apiKey = config.thesaurus_api_key;

  thesaurus = mongo.connect(config.db_url, ['words']);

  processRequest = function(request) {
    var data, type, validateGet, validatePost;
    validateGet = function(data) {
      return data.query.word;
    };
    validatePost = function(data) {
      if ((data.query.original != null) && (data.query.replacement != null) && (data.query.type != null)) {
        return data.query;
      }
    };
    data = url.parse(request.url, true);
    type = request.method;
    if ((data != null ? data.query : void 0) && (type === 'GET' || type === 'POST')) {
      if (type === 'GET') {
        return validateGet(data);
      } else {
        return validatePost(data);
      }
    }
  };

  accessApi = function(word, response) {
    var processWordData;
    processWordData = function(word, wordStr) {
      var convert, type;
      convert = function(type) {
        var list, string;
        for (list in word[type]) {
          word[type][list] = (function() {
            var _i, _len, _ref, _results;
            _ref = word[type][list];
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              string = _ref[_i];
              _results.push({
                is: string
              });
            }
            return _results;
          })();
        }
        return type;
      };
      word.types = (function() {
        var _results;
        _results = [];
        for (type in word) {
          _results.push(convert(type));
        }
        return _results;
      })();
      word.is = wordStr;
      word.rank = 0;
      return word;
    };
    if (apiKey) {
      return request('http://words.bighugelabs.com/api/2/' + apiKey + '/' + word + '/json', function(error, headers, body) {
        var wordObject;
        if (!error && headers.statusCode === 200) {
          try {
            wordObject = processWordData(JSON.parse(body), word);
            response.writeHead(200, {
              'Content-type': 'text/json'
            });
            response.end(JSON.stringify(wordObject));
            return thesaurus.words.save(wordObject, function(error, saved) {
              var msg;
              if (error || !saved) {
                msg = 'There was a problem saving a word:';
                return output(msg, error, wordObject);
              }
            });
          } catch (e) {
            return output('There was a parse error:', e);
          }
        } else {
          return output('API access error:', error, headers);
        }
      });
    }
  };

  handleWordQuery = function(request, response) {
    var word;
    word = processRequest(request);
    if (word) {
      return thesaurus.words.find({
        is: word
      }, function(error, result) {
        var _ref;
        if (error) {
          return output('There was an query error:', error);
        } else if ((result != null ? (_ref = result[0]) != null ? _ref.is : void 0 : void 0) === word) {
          try {
            response.writeHead(200, {
              'Content-type': 'text/json'
            });
            return response.end(JSON.stringify(result[0]));
          } catch (e) {
            return output('There was a parse error:', e);
          }
        } else {
          return accessApi(word, response);
        }
      });
    } else {
      response.writeHead(400);
      return response.end();
    }
  };

  handleWordUpdate = function(request, response) {};

  module.exports.handleWordQuery = handleWordQuery;

  module.exports.handleWordUpdate = handleWordUpdate;

}).call(this);
